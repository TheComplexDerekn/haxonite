module map2 is

  func main() is
    var m = new Map[String,Int];

    // this is the first few paragraphs of the wikipedia entry for
    // "compiler"

    var i = 1;
    set(m, "In", i);  i = i+1;
    set(m, "computing", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "compiler", i);  i = i+1;
    set(m, "is", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "computer", i);  i = i+1;
    set(m, "program", i);  i = i+1;
    set(m, "that", i);  i = i+1;
    set(m, "translates", i);  i = i+1;
    set(m, "computer", i);  i = i+1;
    set(m, "code", i);  i = i+1;
    set(m, "written", i);  i = i+1;
    set(m, "in", i);  i = i+1;
    set(m, "one", i);  i = i+1;
    set(m, "programming", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "the", i);  i = i+1;
    set(m, "source", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "into", i);  i = i+1;
    set(m, "another", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "the", i);  i = i+1;
    set(m, "target", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "The", i);  i = i+1;
    set(m, "name", i);  i = i+1;
    set(m, "compiler", i);  i = i+1;
    set(m, "is", i);  i = i+1;
    set(m, "primarily", i);  i = i+1;
    set(m, "used", i);  i = i+1;
    set(m, "for", i);  i = i+1;
    set(m, "programs", i);  i = i+1;
    set(m, "that", i);  i = i+1;
    set(m, "translate", i);  i = i+1;
    set(m, "source", i);  i = i+1;
    set(m, "code", i);  i = i+1;
    set(m, "from", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "high", i);  i = i+1;
    set(m, "level", i);  i = i+1;
    set(m, "programming", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "to", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "low", i);  i = i+1;
    set(m, "level", i);  i = i+1;
    set(m, "programming", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "e.g.", i);  i = i+1;
    set(m, "assembly", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "object", i);  i = i+1;
    set(m, "code", i);  i = i+1;
    set(m, "or", i);  i = i+1;
    set(m, "machine", i);  i = i+1;
    set(m, "code", i);  i = i+1;
    set(m, "to", i);  i = i+1;
    set(m, "create", i);  i = i+1;
    set(m, "an", i);  i = i+1;
    set(m, "executable", i);  i = i+1;
    set(m, "program", i);  i = i+1;
    set(m, "There", i);  i = i+1;
    set(m, "are", i);  i = i+1;
    set(m, "many", i);  i = i+1;
    set(m, "different", i);  i = i+1;
    set(m, "types", i);  i = i+1;
    set(m, "of", i);  i = i+1;
    set(m, "compilers", i);  i = i+1;
    set(m, "which", i);  i = i+1;
    set(m, "produce", i);  i = i+1;
    set(m, "output", i);  i = i+1;
    set(m, "in", i);  i = i+1;
    set(m, "different", i);  i = i+1;
    set(m, "useful", i);  i = i+1;
    set(m, "forms", i);  i = i+1;
    set(m, "A", i);  i = i+1;
    set(m, "cross-compiler", i);  i = i+1;
    set(m, "produces", i);  i = i+1;
    set(m, "code", i);  i = i+1;
    set(m, "for", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "different", i);  i = i+1;
    set(m, "CPU", i);  i = i+1;
    set(m, "or", i);  i = i+1;
    set(m, "operating", i);  i = i+1;
    set(m, "system", i);  i = i+1;
    set(m, "than", i);  i = i+1;
    set(m, "the", i);  i = i+1;
    set(m, "one", i);  i = i+1;
    set(m, "on", i);  i = i+1;
    set(m, "which", i);  i = i+1;
    set(m, "the", i);  i = i+1;
    set(m, "cross-compiler", i);  i = i+1;
    set(m, "itself", i);  i = i+1;
    set(m, "runs", i);  i = i+1;
    set(m, "A", i);  i = i+1;
    set(m, "bootstrap", i);  i = i+1;
    set(m, "compiler", i);  i = i+1;
    set(m, "is", i);  i = i+1;
    set(m, "often", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "temporary", i);  i = i+1;
    set(m, "compiler", i);  i = i+1;
    set(m, "used", i);  i = i+1;
    set(m, "for", i);  i = i+1;
    set(m, "compiling", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "more", i);  i = i+1;
    set(m, "permanent", i);  i = i+1;
    set(m, "or", i);  i = i+1;
    set(m, "better", i);  i = i+1;
    set(m, "optimised", i);  i = i+1;
    set(m, "compiler", i);  i = i+1;
    set(m, "for", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "Related", i);  i = i+1;
    set(m, "software", i);  i = i+1;
    set(m, "include", i);  i = i+1;
    set(m, "decompilers", i);  i = i+1;
    set(m, "programs", i);  i = i+1;
    set(m, "that", i);  i = i+1;
    set(m, "translate", i);  i = i+1;
    set(m, "from", i);  i = i+1;
    set(m, "low", i);  i = i+1;
    set(m, "level", i);  i = i+1;
    set(m, "languages", i);  i = i+1;
    set(m, "to", i);  i = i+1;
    set(m, "higher", i);  i = i+1;
    set(m, "level", i);  i = i+1;
    set(m, "ones", i);  i = i+1;
    set(m, "programs", i);  i = i+1;
    set(m, "that", i);  i = i+1;
    set(m, "translate", i);  i = i+1;
    set(m, "between", i);  i = i+1;
    set(m, "high", i);  i = i+1;
    set(m, "level", i);  i = i+1;
    set(m, "languages", i);  i = i+1;
    set(m, "usually", i);  i = i+1;
    set(m, "called", i);  i = i+1;
    set(m, "source", i);  i = i+1;
    set(m, "to", i);  i = i+1;
    set(m, "source", i);  i = i+1;
    set(m, "compilers", i);  i = i+1;
    set(m, "or", i);  i = i+1;
    set(m, "transpilers", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "rewriters", i);  i = i+1;
    set(m, "usually", i);  i = i+1;
    set(m, "programs", i);  i = i+1;
    set(m, "that", i);  i = i+1;
    set(m, "translate", i);  i = i+1;
    set(m, "the", i);  i = i+1;
    set(m, "form", i);  i = i+1;
    set(m, "of", i);  i = i+1;
    set(m, "expressions", i);  i = i+1;
    set(m, "without", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "change", i);  i = i+1;
    set(m, "of", i);  i = i+1;
    set(m, "language", i);  i = i+1;
    set(m, "and", i);  i = i+1;
    set(m, "compiler", i);  i = i+1;
    set(m, "compilers", i);  i = i+1;
    set(m, "compilers", i);  i = i+1;
    set(m, "that", i);  i = i+1;
    set(m, "produce", i);  i = i+1;
    set(m, "compilers", i);  i = i+1;
    set(m, "or", i);  i = i+1;
    set(m, "parts", i);  i = i+1;
    set(m, "of", i);  i = i+1;
    set(m, "them", i);  i = i+1;
    set(m, "often", i);  i = i+1;
    set(m, "in", i);  i = i+1;
    set(m, "a", i);  i = i+1;
    set(m, "generic", i);  i = i+1;
    set(m, "and", i);  i = i+1;
    set(m, "reusable", i);  i = i+1;
    set(m, "way", i);  i = i+1;
    set(m, "so", i);  i = i+1;
    set(m, "as", i);  i = i+1;
    set(m, "to", i);  i = i+1;
    set(m, "be", i);  i = i+1;
    set(m, "able", i);  i = i+1;
    set(m, "to", i);  i = i+1;
    set(m, "produce", i);  i = i+1;
    set(m, "many", i);  i = i+1;
    set(m, "differing", i);  i = i+1;
    set(m, "compilers", i);  i = i+1;

    write("--- A ---\n");
    var n = #m;
    write($"inserts = {i}, length = {n}\n");
    check(m, "A");
    check(m, "a");
    check(m, "compiler");
    check(m, "compilers");
    check(m, "compiler's");
    check(m, "language");
    check(m, "different");
    check(m, "the");
    check(m, "generic");
    check(m, "and");
    check(m, "reusable");

    delete(m, "compilers");
    delete(m, "language");
    delete(m, "different");
    delete(m, "the");
    delete(m, "xyz");

    write("--- B ---\n");
    n = #m;
    write($"length = {n}\n");
    check(m, "A");
    check(m, "a");
    check(m, "compiler");
    check(m, "compilers");
    check(m, "compiler's");
    check(m, "language");
    check(m, "different");
    check(m, "the");
    check(m, "generic");
    check(m, "and");
    check(m, "reusable");

    delete(m, "In");
    delete(m, "computing");
    delete(m, "a");
    delete(m, "compiler");
    delete(m, "is");
    delete(m, "a");
    delete(m, "computer");
    delete(m, "program");
    delete(m, "that");
    delete(m, "translates");
    delete(m, "computer");
    delete(m, "code");
    delete(m, "written");
    delete(m, "in");
    delete(m, "one");
    delete(m, "programming");
    delete(m, "language");
    delete(m, "the");
    delete(m, "source");
    delete(m, "language");
    delete(m, "into");
    delete(m, "another");
    delete(m, "language");
    delete(m, "the");
    delete(m, "target");
    delete(m, "language");
    delete(m, "The");
    delete(m, "name");
    delete(m, "compiler");
    delete(m, "is");
    delete(m, "primarily");
    delete(m, "used");
    delete(m, "for");
    delete(m, "programs");
    delete(m, "that");
    delete(m, "translate");
    delete(m, "source");
    delete(m, "code");
    delete(m, "from");
    delete(m, "a");
    delete(m, "high");
    delete(m, "level");
    delete(m, "programming");
    delete(m, "language");
    delete(m, "to");
    delete(m, "a");
    delete(m, "low");
    delete(m, "level");
    delete(m, "programming");
    delete(m, "language");
    delete(m, "e.g.");
    delete(m, "assembly");
    delete(m, "language");
    delete(m, "object");
    delete(m, "code");
    delete(m, "or");
    delete(m, "machine");
    delete(m, "code");
    delete(m, "to");
    delete(m, "create");
    delete(m, "an");
    delete(m, "executable");
    delete(m, "program");
    delete(m, "There");
    delete(m, "are");
    delete(m, "many");
    delete(m, "different");
    delete(m, "types");
    delete(m, "of");
    delete(m, "compilers");
    delete(m, "which");
    delete(m, "produce");
    delete(m, "output");
    delete(m, "in");
    delete(m, "different");
    delete(m, "useful");
    delete(m, "forms");
    delete(m, "A");
    delete(m, "cross-compiler");
    delete(m, "produces");
    delete(m, "code");
    delete(m, "for");
    delete(m, "a");
    delete(m, "different");
    delete(m, "CPU");
    delete(m, "or");
    delete(m, "operating");
    delete(m, "system");
    delete(m, "than");
    delete(m, "the");
    delete(m, "one");
    delete(m, "on");
    delete(m, "which");
    delete(m, "the");
    delete(m, "cross-compiler");
    delete(m, "itself");
    delete(m, "runs");
    delete(m, "A");
    delete(m, "bootstrap");
    delete(m, "compiler");
    delete(m, "is");
    delete(m, "often");
    delete(m, "a");
    delete(m, "temporary");
    delete(m, "compiler");
    delete(m, "used");
    delete(m, "for");
    delete(m, "compiling");
    delete(m, "a");
    delete(m, "more");
    delete(m, "permanent");
    delete(m, "or");
    delete(m, "better");
    delete(m, "optimised");
    delete(m, "compiler");
    delete(m, "for");
    delete(m, "a");
    delete(m, "language");
    delete(m, "Related");
    delete(m, "software");
    delete(m, "include");
    delete(m, "decompilers");
    delete(m, "programs");
    delete(m, "that");
    delete(m, "translate");
    delete(m, "from");
    delete(m, "low");
    delete(m, "level");
    delete(m, "languages");
    delete(m, "to");
    delete(m, "higher");
    delete(m, "level");
    delete(m, "ones");
    delete(m, "programs");
    delete(m, "that");
    delete(m, "translate");
    delete(m, "between");
    delete(m, "high");
    delete(m, "level");
    delete(m, "languages");
    delete(m, "usually");
    delete(m, "called");
    delete(m, "source");
    delete(m, "to");
    delete(m, "source");
    delete(m, "compilers");
    delete(m, "or");
    delete(m, "transpilers");
    delete(m, "language");
    delete(m, "rewriters");
    delete(m, "usually");
    delete(m, "programs");
    delete(m, "that");
    delete(m, "translate");
    delete(m, "the");
    delete(m, "form");
    delete(m, "of");
    delete(m, "expressions");
    delete(m, "without");
    delete(m, "a");
    delete(m, "change");
    delete(m, "of");
    delete(m, "language");
    delete(m, "and");
    delete(m, "compiler");
    delete(m, "compilers");
    delete(m, "compilers");
    delete(m, "that");
    delete(m, "produce");
    delete(m, "compilers");
    delete(m, "or");
    delete(m, "parts");
    delete(m, "of");
    delete(m, "them");
    delete(m, "often");
    delete(m, "in");
    delete(m, "a");
    delete(m, "generic");
    delete(m, "and");
    delete(m, "reusable");
    delete(m, "way");
    delete(m, "so");
    delete(m, "as");
    delete(m, "to");
    delete(m, "be");
    delete(m, "able");
    delete(m, "to");
    delete(m, "produce");
    delete(m, "many");
    delete(m, "differing");
    delete(m, "compilers");

    write("--- C ---\n");
    n = #m;
    write($"length = {n}\n");
    check(m, "A");
    check(m, "a");
    check(m, "compiler");
    check(m, "compilers");
    check(m, "compiler's");
    check(m, "language");
    check(m, "different");
    check(m, "the");
    check(m, "generic");
    check(m, "and");
    check(m, "reusable");
  end

  func check(m: Map[String,Int], key: String) is
    if contains(m, key) then
      var val = get(m, key);
      write($"{key} -> {val}\n");
    else
      write($"{key} -> undef\n");
    end
  end

end
