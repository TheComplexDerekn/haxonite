#!/usr/bin/perl
#========================================================================
#
# make-ast
#
# Construct a C++ header with AST classes.
#
# Usage: make-ast <grammar.ast >AST.h
#
# Part of the Haxonite project, under the MIT License.
# Copyright 2025 Derek Noonburg
#
#========================================================================

use strict;
use warnings;

# The '#define' header file guard.
my $guard;

# Include directives.
my @includes;

# List of classes. Each class is:
# {
#   name => "ClassName",
#   base => "BaseClass",
#   isBase => 0|1,  # 1 for base class, 0 for regular class
#   fields => [
#     ["name", "Type"],
#     ...
#   ]
# }
my @classes;

# Subclasses of each base class. Each entry is:
# "BaseClassName" => [ "SubclassName", ... ]
my %subclasses;

# List of enums. Each enum is:
# {
#   name => "EnumName",
#   elements => [
#     "elem",
#     ...
#   ]
# }
my @enums;

my $state = "top";
my $lineNum = 1;
my $currentClass;
my $currentEnum;
while (my $line = <>) {
    if ($state eq "top") {
	if ($line =~ /^\s*\#define\s+(\w+)\s*$/) {
	    $guard = $1;
	} elsif ($line =~ /^\s*(\#include\s+.*)$/) {
	    push(@includes, $1);
	} elsif ($line =~ /^\s*baseclass\s+(\w+)\s*$/) {
	    $state = "baseclass";
	    $currentClass = { "name" => $1, "isBase" => 1, "fields" => [] };
	} elsif ($line =~ /^\s*class\s+(\w+)\s*$/) {
	    $state = "class";
	    $currentClass = { "name" => $1, "isBase" => 0, "fields" => [] };
	} elsif ($line =~ /^\s*class\s+(\w+):\s*(\w+)\s*$/) {
	    $state = "class";
	    $currentClass = { "name" => $1, "base" => $2, "isBase" => 0, "fields" => [] };
	    push (@{$subclasses{$2}}, $1);
	} elsif ($line =~ /^\s*enum\s+(\w+)\s*$/) {
	    $state = "enum";
	    $currentEnum = { "name" => $1, elements => [] };
	} elsif ($line =~ /^\s*$/) {
	    # ignore blank lines
	} elsif ($line =~ m@^\s*//@) {
	    # ignore comment lines
	} else {
	    print STDERR ("[$lineNum] Invalid top-level line\n");
	}
    } elsif ($state eq "baseclass") {
	if ($line =~ /^\s*end\s*$/) {
	    $state = "top";
	    push(@classes, $currentClass);
	    $subclasses{$currentClass->{name}} = [];
	    undef $currentClass;
	} elsif ($line =~ /\s*(\w+)*:\s*([\w:*<>].*[\w:*<>])\s*$/) {
	    push(@{$currentClass->{fields}}, [$1, $2]);
	}
    } elsif ($state eq "class") {
	if ($line =~ /^\s*end\s*$/) {
	    $state = "top";
	    push(@classes, $currentClass);
	    undef $currentClass;
	} elsif ($line =~ /\s*(\w+)*:\s*([\w:*<>].*[\w:*<>])\s*$/) {
	    push(@{$currentClass->{fields}}, [$1, $2]);
	}
    } elsif ($state eq "enum") {
	if ($line =~ /^\s*end\s*$/) {
	    $state = "top";
	    push(@enums, $currentEnum);
	    undef $currentEnum;
	} elsif ($line =~ /\s*(\w+)*\s*$/) {
	    push(@{$currentEnum->{elements}}, $1);
	}
    }
    ++$lineNum;
}

print("// generated by make-ast\n");
print("\n");

if (defined($guard)) {
    print("#ifndef $guard\n");
    print("#define $guard\n");
    print("\n");
}

for my $inc (@includes) {
    print("$inc\n");
}
print("#include \"Location.h\"\n");
print("\n");

#--- enums
for my $enum (@enums) {
    print("//------------------------------------------------------------------------\n");
    print("\n");
    print("enum class " . $enum->{name} . " {\n");
    my $nElements = scalar(@{$enum->{elements}});
    for (my $i = 0; $i < $nElements; ++$i) {
	print("  " . $enum->{elements}->[$i]);
	if ($i < $nElements - 1) {
	    print(",");
	}
	print("\n");
    }
    print("};\n");
    print("\n");
}

#--- pre-declare all classes
print("//------------------------------------------------------------------------\n");
print("\n");
for my $class (@classes) {
    print("class " . $class->{name} . ";\n");
}
print("\n");

#--- classes
for my $class (@classes) {
    print("//------------------------------------------------------------------------\n");
    print("\n");

    #--- class decl with base class
    print("class " . $class->{name});
    if (exists($class->{base})) {
	print(": public " . $class->{base});
    }
    print(" {\n");

    print("public:\n");
    print("\n");

    #--- Kind enum and kind() function for base classes
    if ($class->{isBase}) {
	print("  enum class Kind {\n");
	my $sc = $subclasses{$class->{name}};
	for (my $i = 0; $i < scalar(@$sc); ++$i) {
	    print("    \l$sc->[$i]");
	    if ($i < scalar(@$sc) - 1) {
		print(",");
	    }
	    print("\n");
	}
	print("  };\n");
	print("\n");
    }

    #--- constructor
    print("  $class->{name}(Location aLoc");
    my $f = $class->{fields};
    for (my $i = 0; $i < scalar(@$f); ++$i) {
        my ($name, $type) = @{$f->[$i]};
	print(", $type a\u$name");
    }
    print(")\n");
    if (exists($class->{base})) {
	print("    : " . $class->{base} . "(aLoc)\n");
    } else {
	print("    : loc(aLoc)\n");
    }
    for (my $i = 0; $i < scalar(@$f); ++$i) {
	print("    , ");
	my ($name, $type) = @{$f->[$i]};
	if ($type =~ /^std::unique_ptr\</ ||
	    $type =~ /^std::vector\<.*std::unique_ptr\</) {
	    print("$name(std::move(a\u$name))\n");
	} else {
	    print("$name(a\u$name)\n");
	}
    }
    print("  {}\n");

    #--- destructor
    if ($class->{isBase}) {
	print("  virtual ~$class->{name}() {}\n");
    }

    #--- kind() function for base classes and subclasses
    if ($class->{isBase}) {
	print("  virtual Kind kind() = 0;\n");
    }
    if (exists($class->{base})) {
	print("  virtual Kind kind() { return Kind::\l$class->{name}; }\n");
    }

    #--- toString() function
    if ($class->{isBase}) {
	print("  virtual std::string toString(int indent = 0) = 0;\n");
    } elsif (exists($class->{base})) {
	print("  virtual std::string toString(int indent = 0);\n");
    } else {
	print("  std::string toString(int indent = 0);\n");
    }

    print("\n");

    #--- fields
    if (!exists($class->{base})) {
	print("  Location loc;\n");
    }
    for my $field (@{$class->{fields}}) {
	my ($name, $type) = @$field;
	print("  $type $name;\n");
    }

    print("};\n");
    print("\n");
}

if (defined($guard)) {
    print("#endif // $guard\n");
}
